<h1>Sprint 4</h1>
<h2>Work Completed</h2>
  <p>In this sprint, we primarily focused on completing the main functionality of our website. While in sprint 3, we set up our database, added functionality to logging in and creating an account, and set up being able to go through the process of accessing the store, adding items to a cart, and going to the credit card page to purchase a package, in sprint 4, we expanded on this, while allowing seemless functionality all the way from opening the page, up to accessing the specific package purchased. More specifically, we added an auth.service to track if the user is logged in or not, added a package.service to track if the user has purchased a package, and added or adjusted other components to ensure that the functionality was working.</p>
  <p>For the login/sign up aspect, we created an authService, which uses a local storage and readonly STORAGE_KEY and NAME_KEY to track whether the user has signed in yet or not. If the user isn't signed in, they cannot access the My Package page or the store page, and are instead redirected to log in. Similar to the package access which is explained below, a boolean is created to detect whether someone is logged in or not. If they are not, the boolean is false. If they are, the boolean changes to true, which then allows the user to access the store and purchase a specific package, as well as changing the app.component page to now display the username, stating that they are logged in. If the user wants to log out, they also now have the option of a log out button, which will reset the boolean to false, and clear out the username. The code for this functionality is described more in the next paragraph, as both services use very similar methods in order to implement this. Overall, this aspect is pivotal in ensuring that our website is running properly, as it sets up the login/logout functions, as well as determining what the user is able to do while they are/aren't logged in.</p>
  <p>For the package access aspect, we first altered the cart.component.ts and the credit-page.component.ts to create 3 booleans, isPackage1, isPackage2, and isPackage3, which track if a package has been purchased. It also creates an items object, which stores the items added to the cart using the cartService. In ngOnInit(), an array of products is made, also taken from the cartService, and if the products' ids in the cart equal 1, 2, 3, then it will update the boolean in the component, but also in the packageService. The packageService is a .ts file which uses the same booleans, and a STORAGE_KEY, as well as local storage, in order to store the boolean once it has been updated, which menas that after logging in and purchasing a package, the user will be able to redirect to other pages while still having access to the package that they purchased. The packageService makes use of 3 setters and 3 getters for the 3 packages, as well as a function to update the local storage after the setters are called, and a clearProductState() function which clears the booleans and resets them to false. This function is also called in the my-package.component which redefined this function, calling it on its own instance of the packageService, while also setting its own private booleans to false. This is then used in the my-package html file, where a "Sell my Package" button is created which allows users to reset the local storage and get rid of their package. Functionally, this is created to demonstrate testing and allow users to see the 3 different packages without having to reset the app every time. In addition to this button, the html file includes ng-template and ng-container, which uses *ngIf and else to make use of the booleans. If package 3 has been purchased, jump to the template for package 3, else if package 2 has been purchased jump to that template, else if package 1 has been purchased jump to that template, else jump to the noPackage template that says that no package has been purchased. By including the packageService, as well as updating the cart and credit-page components to also store and update the booleans, as well as displaying a message saying a certain package is in the cart, it allows the user to add a specific package to the cart, complete the credit page, and have access to that specific page on the My Packages page. Overall, the package access aspect completes the main part of functionality for our website, allowing users who made an account to purchase a specific package, and access the content available in each of these packages. For the 3 packages, the services provided aren't that intricate, with each higher level implementing the previously included services, as well as a few added services. All work for this was done in the my-packages.component.html file, and is not extremely complex, as it is used more just to demonstrate the functionality of "purchasing" a specific package and being able to access it as long as you are logged into your account.</p>
<p>Outside of these main aspects, some smaller functions were added, such as the cart now showing the total for the items being purchased, which just uses a for loop and adds the total for each item to a variable, as well as the user now being able to clear the cart before purchasing. While these smaller, quality-of-life changes don't really affect the functionality of the website, they add some smaller aspects which make the site feel more complete.</p>
<p>Overall, while our website can still be infinitely expanded upon, the general framework for the site has been set up, and it includes all necessary functionality that is needed in order for it to be pitched. While the services provided can be improved, and the overall style and look of the site can be enhanced, the site works as intended, and uses the implementation described above to do so.</p>
<h2>List of Frontend Unit Tests</h2>
  <ul>
      <li>Login Spec Test to make sure Login in page can take in two and only submits when two</li>
      <li>Credit Page Spec test to make sure submissions only go through when the guidlines for each field were met</li>
  </ul>
<h2>List of Backend Unit Tests</h2>
   <ul>  
    <li>Test Main: This function sets up the database and runs the other tests. It tests the connection to the database and migration of the user table.</li>
  <li>TestNewUser: This function tests the creation of a new user through the NewUser function. It sends an HTTP POST request to the "/users" endpoint with a username and password in the request body. It checks if the response status code is http.StatusOK and if the response body contains the expected response message.</li>
  <li>TestLoginHandler: This function tests the user login functionality through the loginHandler function. It sends an HTTP POST request to the "/login" endpoint with a username and password in the request body. It checks if the response status code is http.StatusOK and if the response body contains the expected response message.</li>
  <li>TestUpdateUser: This function tests the user update functionality through the UpdateUser function. It sends an HTTP PUT request to the "/user/{username}/{email}" endpoint with a new username, email, and password in the request body. It checks if the response status code is http.StatusOK and if the response body contains the expected response message.
</li>
  <li>TestAllUsers: This function tests the retrieval of all users through the AllUsers function. It sends an HTTP GET request to the "/users" endpoint. It checks if the response status code is http.StatusOK. The JSON response check is omitted due to the variability/volatility of the database.</li>
  </ul>
<h2>List of Cypress Tests</h2>
   <ul>
    <li>Login: Confirms the correct routing of the login button</li>
    <li>Feedback: Confirms the correct output based on inputted information in the feedback form on the home page</li>
    <li>Routing: Confirms correct routing from home page to other pages and back to the original page</li>
    <li>Credit: Confirms the correct output of the credit page based on valid and invalid inputs</li>
   </ul>
<h2>Documentation for Backend API</h2>
<p>
This backend API is built using Golang and provides several endpoints for managing user data stored in a SQLite database. 
It uses the GORM library to interface with the database and allows for creating new users, retrieving all users, deleting users,
and updating user data. Additionally, it includes a login endpoint that checks user credentials against the database and returns 
a success or failure response. The API communicates via JSON and returns JSON-encoded responses. Overall, this API provides basic 
CRUD functionality for managing user data and authentication.
 </p>
  <li>TestAllUsers: This function tests the retrieval of all users through the AllUsers function. It sends an HTTP GET request to the "/users" endpoint. It checks if the response status code is http.StatusOK. The JSON response check is omitted due to the variability/volatility of the database.</li>
  </ul>
<h4>List of Functions</h4>
<ul>
  <li> AllUsers: retrieves all users from the database and returns them as JSON to the client. </li>
  <li>NewUser: adds a new user to the database based on the data sent in the request body. Returns the added user as JSON to the client. </li>
  <li>DeleteUser: deletes a user from the database based on the username and password sent in the request body. Returns a response indicating success or failure. </li>
  <li>UpdateUser: updates a user in the database based on the username and password sent in the request body. Only the package status can be updated. Returns a response indicating success or failure. </li>
  <li>loginHandler: authenticates a user based on the username and password sent in the request body. Returns a response indicating success or failure. </li>
  <h3>Bcrypt Password Hashing</h3>
  <li>
Bcrypt is a password hashing algorithm that converts plaintext passwords in hashes. Password hashing is a method used to store passwords in a secure way, by converting the password into a unique string of characters, called a hash. This is important because if a database containing user passwords is compromised, an attacker can use the passwords to gain access to user accounts. Hashing makes it difficult for attackers to obtain the actual passwords, as they are converted into an unintelligible format. Additionally, hashing algorithms are designed to be irreversible, meaning that it is difficult to determine the original password from the hash value, adding an extra layer of security.
 main</li>
 </ul>
